/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>
#include <stm32f1xx.h>
#include <stdio.h>
#include "ringbuf.h"
#include "uart.h"
#include "timers.h"
#include "gpio.h"
#include "rcc.h"
#include <string.h>
#include <stdio.h>


#define MAX_STRING_LENGTH (512)
char str[MAX_STRING_LENGTH] = {0};
char str_message[MAX_STRING_LENGTH] = {0};
uint32_t stringWriteIdx = 0;


volatile bool led_on = 0;

/***************************************************************************//**

  \details  This function enables the HSI clock as a system clock and generate
            the 8MHz. The Internal HSI Clock is 8MHz. So, we are not using PLL
            and not dividing, Multiplying. So, we will get the 8MHz as it is.

  \return   void

  \retval   none

*******************************************************************************/

static void SetSystemClockTo8Mhz(void)
{
  /* Enabling the HSI clock - If not enabled and ready */
  if( (RCC->CR & RCC_CR_HSIRDY) == 0)
  {
    RCC->CR |= RCC_CR_HSION;  /* HSION=1 */

    /* Waiting until HSI clock is ready */
    while( (RCC->CR & RCC_CR_HSIRDY) == 0);
  }

  /* Select AHB prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_HPRE_DIV1;

  /* APB1 prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_PPRE1_DIV1;

  /* APB2 prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

  /* Select the HSI as system clock source */
  RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
  RCC->CFGR |= RCC_CFGR_SW_HSI;

  FLASH->ACR  |= FLASH_ACR_LATENCY_2;

  /* Disabling HSE Clock */
  RCC->CR &= ~RCC_CR_HSEON;
}



void ConfigureRCC(void)
{
	// Enable peripheral clocks: USART2
	RCC->APB1ENR  |=  ( RCC_APB1ENR_USART2EN );

	// Enable peripheral clocks: PORTA
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;

	// Enable peripheral clocks: PORTC
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;

	// Enable the APB clock FOR TIM3
	SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);
}















int main(void)
{
	/* Set System clock to 8 MHz using HSI */
	SetSystemClockTo8Mhz();
	ConfigureRCC();
	ConfigureGPIO();
	/* Configure the Timer 3 */
	ConfigureTimer3();
	ConfigureUART();
	EnableUART();
	ConfigureGPIO();
	__DSB();



	while(1)
	{
		while (uart_data_available()){
			uint8_t data = uart_read_byte();
			if (data == '\r') {
				// Terminate the current string
				str[stringWriteIdx] = '\0';

				// Process the current string (e.g., print it, store it, etc.)
				int ledNumber, value;
			    if (sscanf(str, "set-led %d,%d", &ledNumber, &value) == 2)
			    {
			    	if (((ledNumber == 0) || (ledNumber == 1)) && (value >= 1) && (value < 5000)){
			    		if (ledNumber == 0){
			    			if(led_on == 0){
			    				GPIOA -> ODR |= GPIO_ODR_ODR5;
			    				EnableTimer3((uint32_t)value);
			    				led_on = 1;
			    			}
			    		}
			    		if (ledNumber == 1){
			    			if(led_on == 0){
			    				GPIOA -> ODR |= GPIO_ODR_ODR5;
			    				EnableTimer3((uint32_t)value);
			    				led_on = 1;
			    			}
			    		}
			    	}
			    }
			    else
			    {
			    	int len = 0;
					// Set message string to zeros
			    	memset(str_message, 0, sizeof(str_message));
				    if (sscanf(str, "echo %d,%511s\r", &len, str_message) == 2)
				    {
				    	if((len >= 0) && (len <=300)){
				    		uart_send_string("data: ");
					    	uart_send_string(str_message);
				    		uart_send_string("\n");
				    		uart_send_string("OK\r\n");
				    	}

				    }
			    }

				// Reset the index for the next string
				stringWriteIdx = 0;
				// Set incoming string buffer to zeros
				memset(str, 0, sizeof(str));
			}
			else if (stringWriteIdx < (MAX_STRING_LENGTH - 1))
			{
				// Append the byte to the string if there's room
				str[stringWriteIdx] = data;
				stringWriteIdx++;
			}
			else
			{
				// String buffer is full, handle the overflow if needed
				// ...
			}
		}


		bool button_high = !(GPIOC->IDR & (1<<13));
		if(button_high)
		{
			int val = 3999;
			if(led_on == 0){
				GPIOA -> ODR |= GPIO_ODR_ODR5;
				EnableTimer3((uint32_t)val);
				led_on = 1;
			}

		}
	}
}


void TIM3_IRQHandler(void)
{
  /* if UIF flag is set */
  if(TIM3->SR & TIM_SR_UIF)
  {
	DisableTimer3();
    if(led_on)
    {
    	// https://gist.github.com/iwalpola/6c36c9573fd322a268ce890a118571ca
    	GPIOA -> ODR &= ~(GPIO_ODR_ODR5);
    	led_on = 0;
    }
    /* Clear the Interrupt Status */
    TIM3->SR &= ~TIM_SR_UIF;
  }
}








