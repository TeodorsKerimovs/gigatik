/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>
#include <stm32f1xx.h>
#include <stdio.h>
#include "ringbuf.h"

#define RING_BUFFER_SIZE (512)

static ring_buffer_t rb = {0U}; // initialize all memebers to zero
static uint8_t data_buffer[RING_BUFFER_SIZE] = {0U};


static volatile bool led_on = 0;

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
/***************************************************************************//**

  \details  This function enables the HSI clock as a system clock and generate
            the 8MHz. The Internal HSI Clock is 8MHz. So, we are not using PLL
            and not dividing, Multiplying. So, we will get the 8MHz as it is.

  \return   void

  \retval   none

*******************************************************************************/

static void SetSystemClockTo8Mhz(void)
{
  /* Enabling the HSI clock - If not enabled and ready */
  if( (RCC->CR & RCC_CR_HSIRDY) == 0)
  {
    RCC->CR |= RCC_CR_HSION;  /* HSION=1 */

    /* Waiting until HSI clock is ready */
    while( (RCC->CR & RCC_CR_HSIRDY) == 0);
  }

  /* Select AHB prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_HPRE_DIV1;

  /* APB1 prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_PPRE1_DIV1;

  /* APB2 prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

  /* Select the HSI as system clock source */
  RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
  RCC->CFGR |= RCC_CFGR_SW_HSI;

  FLASH->ACR  |= FLASH_ACR_LATENCY_2;

  /* Disabling HSE Clock */
  RCC->CR &= ~RCC_CR_HSEON;
}













static void ConfigureUART(void)
{

	// set databits
	// set parity to 0
	// set stop bits to 1

	ring_buffer_setup(&rb, data_buffer, RING_BUFFER_SIZE);

	// Enable peripheral clocks: USART2.
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
	RCC->APB1ENR  |=  ( RCC_APB1ENR_USART2EN );

	// Set the baud rate to 9600.
	uint32_t SystemCoreClock = 8000000;
	uint16_t uartdiv = SystemCoreClock / 9600;

	USART2->BRR = ( ( ( uartdiv / 16 ) << USART_BRR_DIV_Mantissa_Pos ) |
	                ( ( uartdiv % 16 ) << USART_BRR_DIV_Fraction_Pos ) );

	// Configure pins A2, A3 for USART2.
	GPIOA->CRL    &= ( GPIO_CRL_MODE2 |
					 GPIO_CRL_CNF2 |
					 GPIO_CRL_MODE3 |
					 GPIO_CRL_CNF3 );

	GPIOA->CRL    |= ( ( 0x1 << GPIO_CRL_MODE2_Pos ) |
					 ( 0x2 << GPIO_CRL_CNF2_Pos ) |
					 ( 0x0 << GPIO_CRL_MODE3_Pos ) |
					 ( 0x1 << GPIO_CRL_CNF3_Pos ) );


	NVIC_SetPriorityGrouping( 0 );
	uint32_t uart_pri_encoding = NVIC_EncodePriority( 0, 1, 0 );
 	NVIC_SetPriority( USART2_IRQn, uart_pri_encoding );
	NVIC_EnableIRQ( USART2_IRQn );



}

static void EnableUART(void){
	// Enable the USART peripheral with interrupt
	USART2->CR1 |= ( USART_CR1_RE |
					 USART_CR1_TE |
					 USART_CR1_UE |
					 USART_CR1_RXNEIE );
}


// USART2 interrupt handler
void USART2_IRQHandler( void ) {
    // 'Receive register not empty' interrupt.
    if ( USART2->SR & USART_SR_RXNE ) {
    	if(ring_buffer_write(&rb, (uint8_t)USART2->DR)){
    		//handle failure, when running out of buffer size?

    	}
    }
}


uint32_t uart_read(uint8_t* data, const uint32_t length){
	if (length == 0) {
		return 0;
	}

	for (uint32_t bytes_read = 0; bytes_read < length; bytes_read++){
		if(!ring_buffer_read(&rb, &data[bytes_read])){
			return bytes_read;
		}
	}

	return length;
}

uint8_t uart_read_byte(void){
	uint8_t byte = 0;
	(void)uart_read(&byte, 1); //explicitly ignore
	return byte;
}


bool uart_data_available(void) {
	return ring_buffer_empty(&rb);
}






static void ConfigureTimer3(void)
{
  /* Enable the APB clock FOR TIM3  */
  SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);
  /* fCK_PSC / (PSC[15:0] + 1)
     (8 MHz / (7999+1)) = 1 KHz timer clock speed */
  TIM3->PSC = 7999;
  /* (1 KHz / 1000) = 1Hz = 1s */
  /* So, this will generate the 1s delay */
  TIM3->ARR = 999;
  /* Enable the Interrupt */
  TIM3->DIER |= TIM_DIER_UIE;
  /* Clear the Interrupt Status */
  TIM3->SR &= ~TIM_SR_UIF;
  /* Enable NVIC Interrupt for Timer 3 */


  NVIC_SetPriorityGrouping( 0 );
  uint32_t tim3_pri_encoding = NVIC_EncodePriority( 0, 2, 0 );
  NVIC_SetPriority( TIM3_IRQn, tim3_pri_encoding );
  NVIC_EnableIRQ(TIM3_IRQn);

}

static void EnableTimer3(uint32_t ms)
{
	TIM3->ARR = ms;
	TIM3->CR1 = TIM_CR1_CEN;
}

void DisableTimer3(void)
{
	TIM3->CR1 = ~TIM_CR1_CEN;
}

void TIM3_IRQHandler(void)
{
  /* if UIF flag is set */
  if(TIM3->SR & TIM_SR_UIF)
  {
	DisableTimer3();
    if(led_on)
    {
    	// https://gist.github.com/iwalpola/6c36c9573fd322a268ce890a118571ca
    	GPIOA -> ODR &= ~(GPIO_ODR_ODR5);
    	led_on = 0;
    }
    /* Clear the Interrupt Status */
    TIM3->SR &= ~TIM_SR_UIF;
  }
}



static void ConfigureGPIO(void)
{

	// For Button
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
	GPIOC->CRH &= ~(0xf<<20);  // clear bits (23:22:21:20)
	GPIOC->CRH |= (0x8<<20); // sets to 1:0:0:0)
	GPIOC->ODR &= (1<<13);

	// For LED
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
	GPIOA->CRL &= ~GPIO_CRL_CNF5_Msk; // Clears CNF to set it for output
	GPIOA->CRL |= GPIO_CRL_MODE5_Msk; // Sets Mode, to 11 to make it as output
}







int main(void)
{
  /* Set System clock to 8 MHz using HSI */
  SetSystemClockTo8Mhz();
  /* Configure the Timer 3 */
  ConfigureTimer3();
  ConfigureUART();
  EnableUART();
  ConfigureGPIO();
  __DSB();
// seperate gcc setup



  while(1)
  {
	  while (uart_data_available()){
		  uint8_t data = uart_read_byte();
		  uart_write_byte(data+1);
	  }

	  bool button_high = !(GPIOC->IDR & (1<<13));
	  if(button_high)
	  {
	      GPIOA -> ODR |= GPIO_ODR_ODR5;
	      led_on = 1;
		  EnableTimer3(1000);
	  }
  }
}













