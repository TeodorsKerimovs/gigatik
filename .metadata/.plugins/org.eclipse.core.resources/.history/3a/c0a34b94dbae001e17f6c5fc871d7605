/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stm32f1xx.h>

/***************************************************************************//**
*   \file       main.c
*
*   \details    Blinking Onboard LED with 1 second delay using Timer
*               - STM32 Timer Tutorial
*
*   \author     EmbeTronicX
*
*   \This code is verified with STM32411CE Board
*
*******************************************************************************/
/***************************************************************************//**
  \details  Providing milli seconds Delay by running Timer
  \return   void
  \retval   none
*******************************************************************************/
static void delay( uint32_t ms )
{
  uint32_t i;
  for( i = 0; i <= ms; i++ )
  {
    /* Clear the count */
    TIM3->CNT = 0;

    /* Wait UIF to be set */
    while((TIM3->SR & TIM_SR_UIF) == 0);    /* This will generate 1ms delay */

    /* Reset UIF */
    TIM3->SR &= ~TIM_SR_UIF;
  }
}
/***************************************************************************//**

  \details  This function enables the HSI clock as a system clock and generate
            the 8MHz. The Internal HSI Clock is 8MHz. So, we are not using PLL
            and not dividing, Multiplying. So, we will get the 16MHz as it is.

  \return   void

  \retval   none

*******************************************************************************/
static void SetSystemClockTo8Mhz(void)
{
  /* Enabling the HSI clock - If not enabled and ready */
  if( (RCC->CR & RCC_CR_HSIRDY) == 0)
  {
    RCC->CR |= RCC_CR_HSION;  /* HSION=1 */

    /* Waiting until HSI clock is ready */
    while( (RCC->CR & RCC_CR_HSIRDY) == 0);
  }

  /* Select AHB prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_HPRE_DIV1;

  /* APB1 prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_PPRE1_DIV1;

  /* APB2 prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

  /* Select the HSI as system clock source */
  RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
  RCC->CFGR |= RCC_CFGR_SW_HSI;

  FLASH->ACR  |= FLASH_ACR_LATENCY_2;

  /* Disabling HSE Clock */
  RCC->CR &= ~RCC_CR_HSEON;
}
/***************************************************************************//**
  \details  This function configures the timer 3 to generate the 1ms delay.
  \return   void
  \retval   none
*******************************************************************************/
static void ConfigureTimer3(void)
{
  /* Enable the APB clock FOR TIM3  */
  SET_BIT(RCC->APB1ENR, RCC_APB1ENR_TIM3EN);

  /* fCK_PSC / (PSC[15:0] + 1)
     (16 MHz / (15+1)) = 1 MHz timer clock speed */
  TIM3->PSC = 15;

  /* (1 MHz / 1000) = 1KHz = 1ms */
  /* So, this will generate the 1ms delay */
  TIM3->ARR = 999;

  /* Finally enable TIM3 module */
  TIM3->CR1 = (1 << 0);
}
/***************************************************************************//**
  \details  The main function.  It should not return.
  \return   void
  \retval   none
*******************************************************************************/
int main(void)
{
  /* Set System clock to 16 MHz using HSI */
  SetSystemClockTo8Mhz();

  /* Configure the Timer 3 */
  ConfigureTimer3();

  RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
  __DSB();

  GPIOA->CRL &= ~GPIO_CRL_CNF5_Msk; // Clears CNF to set it for output
  GPIOA->CRL |= GPIO_CRL_MODE5_Msk; // Sets Mode, to 11 to make it as output
  /* Endless loop */

	while(1)
  {
	// https://gist.github.com/iwalpola/6c36c9573fd322a268ce890a118571ca
	GPIOA -> ODR ^= GPIO_ODR_ODR5;
    delay(1000);

	GPIOA -> ODR ^= GPIO_ODR_ODR5;
    delay(1000);
  }

}


#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


