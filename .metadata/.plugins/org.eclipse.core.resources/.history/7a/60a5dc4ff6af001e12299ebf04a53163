/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stdint.h>
#include <stdbool.h>
#include <stm32f1xx.h>
#include <stdio.h>
#include <string.h>

#include "uart.h"
#include "timers.h"
#include "gpio.h"
#include "sysClk.h"
#include "rcc.h"
#include "leds.h"

#include "ringbuf.h"

#define MAX_STRING_LENGTH (512)
char str[MAX_STRING_LENGTH] = {0};
char str_message[MAX_STRING_LENGTH] = {0};
uint32_t stringWriteIdx = 0;

extern volatile bool zero_led_on = 0;
extern volatile bool one_led_on = 0;

int main(void)
{
	/* Set System clock to 8 MHz using HSI */
	SetSystemClockTo8Mhz();
	ConfigureRCC();
	ConfigureTimer3();
	ConfigureTimer4();
	ConfigureUART();
	ConfigureGPIO();
	ConfigureLEDS();
	__DSB();

	EnableUART();
	while(1)
	{
		while (uart_data_available()){
			uint8_t data = uart_read_byte();
			if (data == '\r') {
				// Terminate the current string
				str[stringWriteIdx] = '\0';
				// Process the current string (e.g., print it, store it, etc.)
				int ledNumber, value;
				char extraChar;

				// If there has been an extraChar then it leads to error
				if (sscanf(str, "set-led %d,%d%c", &ledNumber, &value, &extraChar) == 2)
			    {
			    	if (((ledNumber == 0) || (ledNumber == 1)) && (value >= 1) && (value < 5000)){
			    		if (ledNumber == 0){
			    			if(zero_led_on == 0){
					    		uart_send_string("OK\r\n");
			    				turnOnLedZero();
			    				EnableTimer3((uint32_t)value);
			    				zero_led_on = 1;
			    			}
			    		}
			    		if (ledNumber == 1){
			    			if(one_led_on == 0){
					    		uart_send_string("OK\r\n");
			    				turnOnLedOne();
			    				EnableTimer4((uint32_t)value);
			    				one_led_on = 1;
			    			}
			    		}
			    	}
			    }
			    else
			    {
			    	int len = 0;
					// Set message string to zeros
			    	memset(str_message, 0, sizeof(str_message));
				    if (sscanf(str, "echo %d,%511s\r", &len, str_message) == 2)
				    {
				    	if((len >= 0) && (len <=300)){
				    		uart_send_string("data: ");
					    	uart_send_string(str_message);
				    		uart_send_string("\n");
				    		uart_send_string("OK\r\n");
				    	}
				    }
				    else
				    {
				    	uart_send_string("ERROR\r\n");
				    }
			    }
				// Reset the index for the next string
				stringWriteIdx = 0;
				// Set incoming string buffer to zeros
				memset(str, 0, sizeof(str));
			}
			else if (stringWriteIdx < (MAX_STRING_LENGTH - 1))
			{
				// Append the byte to the string if there's room
				str[stringWriteIdx] = data;
				stringWriteIdx++;
			}
			else
			{
				// String buffer overflow is not handled, however it is long enough = 512. Exercise won't have longer than 300
			}
		}
	}
}

void TIM3_IRQHandler(void)
{
  /* if UIF flag is set */
  if(TIM3->SR & TIM_SR_UIF)
  {
	DisableTimer3();
    if(zero_led_on)
    {
    	// https://gist.github.com/iwalpola/6c36c9573fd322a268ce890a118571ca
		turnOffLedZero();
		uart_send_string("led-off: 0\r\n");
    	zero_led_on = 0;
    }
    /* Clear the Interrupt Status */
    TIM3->SR &= ~TIM_SR_UIF;
  }
}

void TIM4_IRQHandler(void)
{
  /* if UIF flag is set */
  if(TIM4->SR & TIM_SR_UIF)
  {
	DisableTimer4();
    if(one_led_on)
    {
		turnOffLedOne();
		uart_send_string("led-off: 1\r\n");
    	one_led_on = 0;
    }
    /* Clear the Interrupt Status */
    TIM4->SR &= ~TIM_SR_UIF;
  }
}

