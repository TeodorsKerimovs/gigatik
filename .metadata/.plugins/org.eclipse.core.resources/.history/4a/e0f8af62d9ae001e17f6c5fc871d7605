/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include<stm32f1xx.h>


/***************************************************************************//**

  \details  This function enables the HSI clock as a system clock and generate
            the 8MHz. The Internal HSI Clock is 8MHz. So, we are not using PLL
            and not dividing, Multiplying. So, we will get the 16MHz as it is.

  \return   void

  \retval   none

*******************************************************************************/
static void SetSystemClockTo8Mhz(void)
{
  /* Enabling the HSI clock - If not enabled and ready */
  if( (RCC->CR & RCC_CR_HSIRDY) == 0)
  {
    RCC->CR |= RCC_CR_HSION;  /* HSION=1 */

    /* Waiting until HSI clock is ready */
    while( (RCC->CR & RCC_CR_HSIRDY) == 0);
  }

  /* Select AHB prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_HPRE_DIV1;

  /* APB1 prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_PPRE1_DIV1;

  /* APB2 prescaler to 1 */
  RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

  /* Select the HSI as system clock source */
  RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
  RCC->CFGR |= RCC_CFGR_SW_HSI;

  FLASH->ACR  |= FLASH_ACR_LATENCY_2;

  /* Disabling HSE Clock */
  RCC->CR &= ~RCC_CR_HSEON;
}




#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
// https://gist.github.com/iwalpola/6c36c9573fd322a268ce890a118571ca
int main(void)
{
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
	__DSB();

	GPIOA->CRL &= ~GPIO_CRL_CNF5_Msk; // Clears CNF to set it for output
	GPIOA->CRL |= GPIO_CRL_MODE5_Msk; // Sets Mode, to 11 to make it as output

    while(1){
        GPIOA -> ODR ^= GPIO_ODR_ODR5;
        for(volatile unsigned x = 0; x < 500000; x++);

    }
    /* Loop forever */
	// for(;;);
}
